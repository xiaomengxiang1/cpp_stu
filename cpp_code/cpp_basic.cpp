// ----------------------------------命名空间----------------------------------

// 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存
// 在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，
// 以避免命名冲突或名字污染，namespace关键字的出现就是针对这个的

// 注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中

// namespace bit {
//     int a = 0;
//     int b = 1;
//     //可以是变量函数类型
//     int Add(int x, int y) {
//         return x + y;
//     }

//     struct Point {
//         int x;
//         int y;
//     };
// }
// #include <stdio.h>
// // 使用using namespace 命名空间名称 引入
// using namespace bit;
// int main() {
//     printf("%d\n", bit::a);
//     int b = Add(20, 30);
//     return 0;
// }

// 命名空间的使用还可以:
// 加命名空间名称及作用域限定符
// int main() {
//     printf("%d\n", Name::a);
//     return 0;
// }

// 或者：
// 使用using将命名空间中某个成员引入
// using Name::b

// ----------------------------------输入输出----------------------------------

// 1. 使用cout标准输出对象(控制台)和cin标准输入对象(键盘)时，必须包含< iostream >头文件
// 以及按命名空间使用方法使用std。

// 2. cout和cin是全局的流对象，endl是特殊的C++符号，表示换行输出，他们都包含在包含<
// iostream >头文件中。

// 3. <<是流插入运算符，>>是流提取运算符。

// 4. 使用C++输入输出更方便，不需要像printf/scanf输入输出时那样，需要手动控制格式。
// C++的输入输出可以自动识别变量类型

// #include<iostream>

// // std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中
// using namespace std;
// int main() {
//     cout << "hello world" << endl;
//     return 0;
// }

// 注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应
// 头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，
// 规定C++头文件不带.h；旧编译器(vc 6.0)中还支持<iostream.h>格式，后续编译器已不支持，因
// 此推荐使用:
// #include <iostream>
// using namespace std;


// #include <iostream>  // 引入输入输出流库，包含 cin 和 cout
// using namespace std; // 使用标准命名空间，避免每次都写 std::

// int main()           // 程序入口函数
// {
//     int a;           // 定义一个整数变量
//     double b;        // 定义一个双精度浮点数变量
//     char c;          // 定义一个字符变量
    
//     // 从标准输入读取数据，自动匹配变量类型
//     cin >> a;        // 读取一个整数到变量 a
//     cin >> b >> c;   // 连续读取一个浮点数和一个字符
    
//     // 输出数据到标准输出
//     cout << a << endl;         // 输出整数 a 并换行
//     cout << b << " " << c;     // 输出浮点数 b、空格和字符 c
//     return 0;                  // 程序正常结束返回 0
// }

// ----------------------------------缺省参数----------------------------------

// 和python一样，有给定默认值的参数放后面，
// 缺省值必须是常量或者全局变量
// C语言不支持（编译器不支持）

// 半缺省
// void Func(int a, int b = 10, int c = 20) {
//     cout<<"a = "<<a<<endl;
//     cout<<"b = "<<b<<endl;
//     cout<<"c = "<<c<<endl;
// }


// ----------------------------------函数重载----------------------------------

//函数名相同，参数不同(类型 or 个数 or 顺序不同)
//返回值可以不同，也可以构成重载

// void Func(int a, int b) {
//     return;
// }
// int Func(int a, int b, int c) {
//     return 0;
// }
// void Func() {
//     return;
// }
// //c中会报错，cpp不会
// int main() {
//     return 0;
// }

//光是返回值不同其他的相同不能构成重载
// void Func() {
//     return;
// }
// int Func() {
//     return;
// }

//---------------------------c语言的程序环境和预处理-----------------------------

//文件list.i list.h test.i 
// 1、预处理 -> 头文件的展开 / 宏替换 / 条件编译 / 去掉注释
// list.i test.i
// 2、编译 -> 检查语法，生成汇编代码
// list.s test.s
// 3、汇编 -> 汇编代码转成二进制的机器码
// list.o test.o
// 4、链接 -> 将两个目标文件链接到一起

// 符号表(链接过程的)
// 寻找全局的一些定义(函数名)
// 将函数分配地址 形成符号表
// 简单解释:
// list.c 中的add函数分配地址0x100
// test.c 中的add函数声明!!分配地址0x000(视为无效地址)(因为test.c中并没有相关函数的实现)  main分配地址0x200
// 当拼接符号表的时候,若含有无效地址，则运用另一个文件里面的符号表

// c语言的分配地址规则：在上述分配地址的时候，在linux下用gcc编译完成，
//                    函数的名字对应着地址(也就是说有函数重名的时候将会使地址不明确，从而产生链接错误)

//---------------------------cpp的函数重载实现-----------------------------


