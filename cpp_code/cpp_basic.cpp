// ----------------------------------命名空间----------------------------------

// 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存
// 在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，
// 以避免命名冲突或名字污染，namespace关键字的出现就是针对这个的

// 注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中

// namespace bit {
//     int a = 0;
//     int b = 1;
//     //可以是变量函数类型
//     int Add(int x, int y) {
//         return x + y;
//     }

//     struct Point {
//         int x;
//         int y;
//     };
// }
// #include <stdio.h>
// // 使用using namespace 命名空间名称 引入
// using namespace bit;
// int main() {
//     printf("%d\n", bit::a);
//     int b = Add(20, 30);
//     return 0;
// }

// 命名空间的使用还可以:
// 加命名空间名称及作用域限定符
// int main() {
//     printf("%d\n", Name::a);
//     return 0;
// }

// 或者：
// 使用using将命名空间中某个成员引入    
// using Name::b

// ----------------------------------输入输出----------------------------------

// 1. 使用cout标准输出对象(控制台)和cin标准输入对象(键盘)时，必须包含< iostream >头文件
// 以及按命名空间使用方法使用std。

// 2. cout和cin是全局的流对象，endl是特殊的C++符号，表示换行输出，他们都包含在包含<
// iostream >头文件中。

// 3. <<是流插入运算符，>>是流提取运算符。

// 4. 使用C++输入输出更方便，不需要像printf/scanf输入输出时那样，需要手动控制格式。
// C++的输入输出可以自动识别变量类型

// #include<iostream>

// // std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中
// using namespace std;
// int main() {
//     cout << "hello world" << endl;
//     return 0;
// }

// 注意：早期标准库将所有功能在全局域中实现，声明在.h后缀的头文件中，使用时只需包含对应
// 头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，
// 规定C++头文件不带.h；旧编译器(vc 6.0)中还支持<iostream.h>格式，后续编译器已不支持，因
// 此推荐使用:
// #include <iostream>
// using namespace std;


// #include <iostream>  // 引入输入输出流库，包含 cin 和 cout
// using namespace std; // 使用标准命名空间，避免每次都写 std::

// int main()           // 程序入口函数
// {
//     int a;           // 定义一个整数变量
//     double b;        // 定义一个双精度浮点数变量
//     char c;          // 定义一个字符变量
    
//     // 从标准输入读取数据，自动匹配变量类型
//     cin >> a;        // 读取一个整数到变量 a
//     cin >> b >> c;   // 连续读取一个浮点数和一个字符
    
//     // 输出数据到标准输出
//     cout << a << endl;         // 输出整数 a 并换行
//     cout << b << " " << c;     // 输出浮点数 b、空格和字符 c
//     return 0;                  // 程序正常结束返回 0
// }

// ----------------------------------缺省参数----------------------------------

// 和python一样，有给定默认值的参数放后面，
// 缺省值必须是常量或者全局变量
// C语言不支持（编译器不支持）

// 半缺省
// void Func(int a, int b = 10, int c = 20) {
//     cout<<"a = "<<a<<endl;
//     cout<<"b = "<<b<<endl;
//     cout<<"c = "<<c<<endl;
// }


// ----------------------------------函数重载----------------------------------

//函数名相同，参数不同(类型 or 个数 or 顺序不同)
//返回值可以不同，也可以构成重载

// void Func(int a, int b) {
//     return;
// }
// int Func(int a, int b, int c) {
//     return 0;
// }
// void Func() {
//     return;
// }
// //c中会报错，cpp不会
// int main() {
//     return 0;
// }

//光是返回值不同其他的相同不能构成重载
// void Func() {
//     return;
// }
// int Func() {
//     return;
// }

//---------------------------c语言的程序环境和预处理-----------------------------

//文件list.i list.h test.i 
// 1、预处理 -> 头文件的展开 / 宏替换 / 条件编译 / 去掉注释
// list.i test.i
// 2、编译 -> 检查语法，生成汇编代码
// list.s test.s
// 3、汇编 -> 汇编代码转成二进制的机器码
// list.o test.o
// 4、链接 -> 将两个目标文件链接到一起

// 符号表(链接过程的)
// 寻找全局的一些定义(函数名)
// 将函数分配地址 形成符号表
// 简单解释:
// list.c 中的add函数分配地址0x100
// test.c 中的add函数声明!!分配地址0x000(视为无效地址)(因为test.c中并没有相关函数的实现)  main分配地址0x200
// 当拼接符号表的时候,若含有无效地址，则运用另一个文件里面的符号表

// c语言的修饰规则：在上述分配地址的时候，在linux下用gcc编译完成，
//                    函数的名字对应着地址(也就是说有函数重名的时候将会使地址不明确，从而产生链接错误)

//---------------------------cpp的函数重载实现-----------------------------

// c++中函数修饰规则：编译的时候会对函数名进行修饰，不同的参数的函数对应相应的地址，解决了c语言中的链接错误
// 从而实现了函数重载
// 比如add(int x, int x) 修饰成addii    add(double x, double y) 修饰成adddd

// c++实现了一个静态或者动态库当c++和c都想要调用这个库通常会加入 extern "c"
// 作用是使用c语言的修饰规则进行寻找(c++也使用c的规则，因为c++兼容c)

// 以下这两个并不能构成重载，可以根据函数修饰规则推断
// void Func(int x = 10)
// void Func(int x)


//------------------------------------引用--------------------------------------

// 类似python一个变量赋值给另一个
// 引用不是新定义一个变量，而是给已存在变量取了一个别名，
// 编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。

// int main() {
//     int a = 10;
//     int& b = a;
//     int& c = a;
//     //都是10，同一个地址
//     return 0;
// }

// int main() {
//     int a = 10;
//     //int& b;      //引用必须初始化
//     int& c = a;
//     int d = 2;
//     c = d;      //a的值也变成2了   所以这里是将d赋值给c不是将c重新引用在d的身上，也就是说引用一旦创建就固定了

//     return 0;
// }

// int main() {
//     const int a = 10;
//     //int& b = a;  //a的类型是只读的，b是int可读可写，扩大了范围，编译会出错
//     const int& b = a; //ok

//     int c = 1;
//     const int& d = c;   //ok,d是只读，c可读可写，缩小范围
//     //引用取别名的时候，变量访问的权限可以缩小，不能放大
//     return 0;
// }

// int main() {
//     int i = 0;
//     double db = i;  //发生隐式转换
//     //发生隐式转换的过程并不是直接赋值，
//     //而是i从int转换为float/double时，会生成一个临时对象(常性)，然后将临时变量给db

//     const float& a = i;
//     const double& b = i;
//     //这里是因为临时变量(属性为常性)，这里引用的是临时变量
//     // const引用可以绑定到临时对象，并将其生命周期延长到引用的作用域结束
//     return 0;
// }
//权限的放大缩小在引用和指针中才有
// const int x = 10;
// int y = x;
//这样没问题

// ------------------引用返回值的问题------------------------

// int count1() {
//     static int n = 0;
//     n++;
//     //传值返回，会产生一个临时变量，然后返回了临时变量(具有常性)，会产生新的空间
//     return n;
// }

// int& count2() {
//     static int n = 0;
//     n++;
//     //传引用返回，返回的是一个别名(临时别名)，没有产生临时变量，还是n
//     return n;
// }

// int main() {
//     //r1编译不通过，因为引用不能放大范围，而想引用count1的返回值(本质是临时变量),所以要加上const
//     // int& r1 = count1();
//     const int& r1 = count1();

//     int& r2 = count2();

// }
//总结：传值返回会产生一个拷贝的过程，想使用引用返回只能是全局变量或者静态变量，不然会产生危险的引用
//引用返回可以提高效率

// ------------------引用和指针的区别------------------------


// 1.引用概念上定义一个变量的别名，指针存储一个变量地址。
// 2.引用在定义时必须初始化，指针没有要求
// 3.引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体
// 4.没有 NULL 引用，但有 NULL 指针
// 5.在 sizeof 中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数 (32 位平台下占 4 个字节)
// 6.引用自加即引用的实体增加 1，指针自加即指针向后偏移一个类型的大小
// 7.有多级指针，但是没有多级引用
// 8.访问实体方式不同，指针需要显式解引用，引用编译器自己处理
// 9.引用比指针使用起来相对更安全


// ------------------------------------内联函数------------------------------------------

// 空间换时间，适合短小、频繁调用的函数，可以节省创建函数栈帧的开销,主要是给编译器的建议
// inline void Swap(int& a, int& b) {
//     int temp = a;
//     a = b;
//     b = temp;
// }
// c语言要频繁调用这种小函数主要是使用 宏函数来替代


// ------------------------------------auto------------------------------------------
//c++ 11中引入的,智能推导类型

// #include <iostream>
// using namespace std;
// int main() {
//     int a = 10;
//     auto b = a;         // b的类型被推导为int
//     auto& c = a;        // c的类型被推导为int&（引用）
//     auto d = &a;        // d的类型被推导为int*（指针）
    
//     cout << typeid(a).name() << endl;  // 输出a的类型
//     cout << typeid(b).name() << endl;  // 输出b的类型
//     cout << typeid(c).name() << endl;  // 输出c的类型
//     cout << typeid(d).name() << endl;  // 输出d的类型
// }


// ----------------------------------基于范围的for循环----------------------------------------
// c++98遍历数组：

// #include <iostream>
// using namespace std;
// int main() {
//     int array[] = {1,2,3,4,5};
//     int i = 0;
//     for (i = 0; i < sizeof(array) / sizeof(array[0]); i++) {
//         array[i] *= 2;
//     }

//     for (i = 0; i < sizeof(array) / sizeof(array[0]); i++) {
//         cout << array[i] << " ";
//     }
//     cout << endl;
//     return 0;
// }

// c++11使用auto,语法糖
// #include <iostream>
// using namespace std;
// int main () {
//     int array[] = {1,2,3,4,5};
//     for (auto& e : array) {
//         e *= 2;
//     }
//     for (auto e : array) {
//         cout << e << " ";
//     }
//     cout << endl;
//     return 0;
// }
// -------------------------空指针nullptr---------------------------------

// 在c++11的定义中有：
// #define NULL 0
// nullptr代表((void*)(0))
// 所以c++11中推荐使用nullptr定义空指针:

// #include <iostream>
// using namespace std;

// void func(int n) {
//     cout << "整型" << endl;
// }

// void func(int* p) {
//     cout << "指针" << endl;
// }

// int main() {
//     func(0);        // 调用func(int)
//     func(NULL);     // 调用func(int)（在C++中）
//     func(nullptr);  // 调用func(int*)
//     return 0;
// }

